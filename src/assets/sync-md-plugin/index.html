<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Sync.md</title>
    <script type="module">
      var st = Object.defineProperty;
      var nt = (e, t, s) =>
        t in e
          ? st(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s })
          : (e[t] = s);
      var oe = (e, t, s) => nt(e, typeof t != 'symbol' ? t + '' : t, s);
      (function () {
        const t = document.createElement('link').relList;
        if (t && t.supports && t.supports('modulepreload')) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) o(n);
        new MutationObserver((n) => {
          for (const i of n)
            if (i.type === 'childList')
              for (const a of i.addedNodes)
                a.tagName === 'LINK' && a.rel === 'modulepreload' && o(a);
        }).observe(document, { childList: !0, subtree: !0 });
        function s(n) {
          const i = {};
          return (
            n.integrity && (i.integrity = n.integrity),
            n.referrerPolicy && (i.referrerPolicy = n.referrerPolicy),
            n.crossOrigin === 'use-credentials'
              ? (i.credentials = 'include')
              : n.crossOrigin === 'anonymous'
                ? (i.credentials = 'omit')
                : (i.credentials = 'same-origin'),
            i
          );
        }
        function o(n) {
          if (n.ep) return;
          n.ep = !0;
          const i = s(n);
          fetch(n.href, i);
        }
      })();
      const rt = !1,
        it = (e, t) => e === t,
        ot = Symbol('solid-track'),
        ke = { equals: it };
      let Re = Ve;
      const K = 1,
        me = 2,
        qe = { owned: null, cleanups: null, context: null, owner: null };
      var E = null;
      let Te = null,
        at = null,
        A = null,
        j = null,
        W = null,
        ve = 0;
      function we(e, t) {
        const s = A,
          o = E,
          n = e.length === 0,
          i = t === void 0 ? o : t,
          a = n
            ? qe
            : { owned: null, cleanups: null, context: i ? i.context : null, owner: i },
          r = n ? e : () => e(() => z(() => le(a)));
        (E = a), (A = null);
        try {
          return de(r, !0);
        } finally {
          (A = s), (E = o);
        }
      }
      function L(e, t) {
        t = t ? Object.assign({}, ke, t) : ke;
        const s = {
            value: e,
            observers: null,
            observerSlots: null,
            comparator: t.equals || void 0,
          },
          o = (n) => (typeof n == 'function' && (n = n(s.value)), We(s, n));
        return [Be.bind(s), o];
      }
      function q(e, t, s) {
        const o = Ee(e, t, !1, K);
        ce(o);
      }
      function lt(e, t, s) {
        Re = pt;
        const o = Ee(e, t, !1, K);
        (o.user = !0), W ? W.push(o) : ce(o);
      }
      function ae(e, t, s) {
        s = s ? Object.assign({}, ke, s) : ke;
        const o = Ee(e, t, !0, 0);
        return (
          (o.observers = null),
          (o.observerSlots = null),
          (o.comparator = s.equals || void 0),
          ce(o),
          Be.bind(o)
        );
      }
      function z(e) {
        if (A === null) return e();
        const t = A;
        A = null;
        try {
          return e();
        } finally {
          A = t;
        }
      }
      function ct(e) {
        lt(() => z(e));
      }
      function dt(e) {
        return (
          E === null || (E.cleanups === null ? (E.cleanups = [e]) : E.cleanups.push(e)), e
        );
      }
      function Be() {
        if (this.sources && this.state)
          if (this.state === K) ce(this);
          else {
            const e = j;
            (j = null), de(() => be(this), !1), (j = e);
          }
        if (A) {
          const e = this.observers ? this.observers.length : 0;
          A.sources
            ? (A.sources.push(this), A.sourceSlots.push(e))
            : ((A.sources = [this]), (A.sourceSlots = [e])),
            this.observers
              ? (this.observers.push(A), this.observerSlots.push(A.sources.length - 1))
              : ((this.observers = [A]), (this.observerSlots = [A.sources.length - 1]));
        }
        return this.value;
      }
      function We(e, t, s) {
        let o = e.value;
        return (
          (!e.comparator || !e.comparator(o, t)) &&
            ((e.value = t),
            e.observers &&
              e.observers.length &&
              de(() => {
                for (let n = 0; n < e.observers.length; n += 1) {
                  const i = e.observers[n],
                    a = Te && Te.running;
                  a && Te.disposed.has(i),
                    (a ? !i.tState : !i.state) &&
                      (i.pure ? j.push(i) : W.push(i), i.observers && He(i)),
                    a || (i.state = K);
                }
                if (j.length > 1e6) throw ((j = []), new Error());
              }, !1)),
          t
        );
      }
      function ce(e) {
        if (!e.fn) return;
        le(e);
        const t = ve;
        ut(e, e.value, t);
      }
      function ut(e, t, s) {
        let o;
        const n = E,
          i = A;
        A = E = e;
        try {
          o = e.fn(t);
        } catch (a) {
          return (
            e.pure && ((e.state = K), e.owned && e.owned.forEach(le), (e.owned = null)),
            (e.updatedAt = s + 1),
            Ge(a)
          );
        } finally {
          (A = i), (E = n);
        }
        (!e.updatedAt || e.updatedAt <= s) &&
          (e.updatedAt != null && 'observers' in e ? We(e, o) : (e.value = o),
          (e.updatedAt = s));
      }
      function Ee(e, t, s, o = K, n) {
        const i = {
          fn: e,
          state: o,
          updatedAt: null,
          owned: null,
          sources: null,
          sourceSlots: null,
          cleanups: null,
          value: t,
          owner: E,
          context: E ? E.context : null,
          pure: s,
        };
        return (
          E === null || (E !== qe && (E.owned ? E.owned.push(i) : (E.owned = [i]))), i
        );
      }
      function Pe(e) {
        if (e.state === 0) return;
        if (e.state === me) return be(e);
        if (e.suspense && z(e.suspense.inFallback)) return e.suspense.effects.push(e);
        const t = [e];
        for (; (e = e.owner) && (!e.updatedAt || e.updatedAt < ve); )
          e.state && t.push(e);
        for (let s = t.length - 1; s >= 0; s--)
          if (((e = t[s]), e.state === K)) ce(e);
          else if (e.state === me) {
            const o = j;
            (j = null), de(() => be(e, t[0]), !1), (j = o);
          }
      }
      function de(e, t) {
        if (j) return e();
        let s = !1;
        t || (j = []), W ? (s = !0) : (W = []), ve++;
        try {
          const o = e();
          return ft(s), o;
        } catch (o) {
          s || (W = null), (j = null), Ge(o);
        }
      }
      function ft(e) {
        if ((j && (Ve(j), (j = null)), e)) return;
        const t = W;
        (W = null), t.length && de(() => Re(t), !1);
      }
      function Ve(e) {
        for (let t = 0; t < e.length; t++) Pe(e[t]);
      }
      function pt(e) {
        let t,
          s = 0;
        for (t = 0; t < e.length; t++) {
          const o = e[t];
          o.user ? (e[s++] = o) : Pe(o);
        }
        for (t = 0; t < s; t++) Pe(e[t]);
      }
      function be(e, t) {
        e.state = 0;
        for (let s = 0; s < e.sources.length; s += 1) {
          const o = e.sources[s];
          if (o.sources) {
            const n = o.state;
            n === K
              ? o !== t && (!o.updatedAt || o.updatedAt < ve) && Pe(o)
              : n === me && be(o, t);
          }
        }
      }
      function He(e) {
        for (let t = 0; t < e.observers.length; t += 1) {
          const s = e.observers[t];
          s.state ||
            ((s.state = me), s.pure ? j.push(s) : W.push(s), s.observers && He(s));
        }
      }
      function le(e) {
        let t;
        if (e.sources)
          for (; e.sources.length; ) {
            const s = e.sources.pop(),
              o = e.sourceSlots.pop(),
              n = s.observers;
            if (n && n.length) {
              const i = n.pop(),
                a = s.observerSlots.pop();
              o < n.length &&
                ((i.sourceSlots[a] = o), (n[o] = i), (s.observerSlots[o] = a));
            }
          }
        if (e.tOwned) {
          for (t = e.tOwned.length - 1; t >= 0; t--) le(e.tOwned[t]);
          delete e.tOwned;
        }
        if (e.owned) {
          for (t = e.owned.length - 1; t >= 0; t--) le(e.owned[t]);
          e.owned = null;
        }
        if (e.cleanups) {
          for (t = e.cleanups.length - 1; t >= 0; t--) e.cleanups[t]();
          e.cleanups = null;
        }
        e.state = 0;
      }
      function ht(e) {
        return e instanceof Error
          ? e
          : new Error(typeof e == 'string' ? e : 'Unknown error', { cause: e });
      }
      function Ge(e, t = E) {
        throw ht(e);
      }
      const gt = Symbol('fallback');
      function Me(e) {
        for (let t = 0; t < e.length; t++) e[t]();
      }
      function wt(e, t, s = {}) {
        let o = [],
          n = [],
          i = [],
          a = 0,
          r = t.length > 1 ? [] : null;
        return (
          dt(() => Me(i)),
          () => {
            let c = e() || [],
              f = c.length,
              d,
              l;
            return (
              c[ot],
              z(() => {
                let u, p, g, m, _, $, N, U, V;
                if (f === 0)
                  a !== 0 &&
                    (Me(i), (i = []), (o = []), (n = []), (a = 0), r && (r = [])),
                    s.fallback &&
                      ((o = [gt]),
                      (n[0] = we((Ie) => ((i[0] = Ie), s.fallback()))),
                      (a = 1));
                else if (a === 0) {
                  for (n = new Array(f), l = 0; l < f; l++) (o[l] = c[l]), (n[l] = we(k));
                  a = f;
                } else {
                  for (
                    g = new Array(f),
                      m = new Array(f),
                      r && (_ = new Array(f)),
                      $ = 0,
                      N = Math.min(a, f);
                    $ < N && o[$] === c[$];
                    $++
                  );
                  for (N = a - 1, U = f - 1; N >= $ && U >= $ && o[N] === c[U]; N--, U--)
                    (g[U] = n[N]), (m[U] = i[N]), r && (_[U] = r[N]);
                  for (u = new Map(), p = new Array(U + 1), l = U; l >= $; l--)
                    (V = c[l]),
                      (d = u.get(V)),
                      (p[l] = d === void 0 ? -1 : d),
                      u.set(V, l);
                  for (d = $; d <= N; d++)
                    (V = o[d]),
                      (l = u.get(V)),
                      l !== void 0 && l !== -1
                        ? ((g[l] = n[d]),
                          (m[l] = i[d]),
                          r && (_[l] = r[d]),
                          (l = p[l]),
                          u.set(V, l))
                        : i[d]();
                  for (l = $; l < f; l++)
                    l in g
                      ? ((n[l] = g[l]), (i[l] = m[l]), r && ((r[l] = _[l]), r[l](l)))
                      : (n[l] = we(k));
                  (n = n.slice(0, (a = f))), (o = c.slice(0));
                }
                return n;
              })
            );
            function k(u) {
              if (((i[l] = u), r)) {
                const [p, g] = L(l);
                return (r[l] = g), t(c[l], p);
              }
              return t(c[l]);
            }
          }
        );
      }
      function te(e, t) {
        return z(() => e(t || {}));
      }
      const yt = (e) => `Stale read from <${e}>.`;
      function kt(e) {
        const t = 'fallback' in e && { fallback: () => e.fallback };
        return ae(wt(() => e.each, e.children, t || void 0));
      }
      function ge(e) {
        const t = e.keyed,
          s = ae(() => e.when, void 0, void 0),
          o = t ? s : ae(s, void 0, { equals: (n, i) => !n == !i });
        return ae(
          () => {
            const n = o();
            if (n) {
              const i = e.children;
              return typeof i == 'function' && i.length > 0
                ? z(() =>
                    i(
                      t
                        ? n
                        : () => {
                            if (!z(o)) throw yt('Show');
                            return s();
                          },
                    ),
                  )
                : i;
            }
            return e.fallback;
          },
          void 0,
          void 0,
        );
      }
      const mt = (e) => ae(() => e());
      function Pt(e, t, s) {
        let o = s.length,
          n = t.length,
          i = o,
          a = 0,
          r = 0,
          c = t[n - 1].nextSibling,
          f = null;
        for (; a < n || r < i; ) {
          if (t[a] === s[r]) {
            a++, r++;
            continue;
          }
          for (; t[n - 1] === s[i - 1]; ) n--, i--;
          if (n === a) {
            const d = i < o ? (r ? s[r - 1].nextSibling : s[i - r]) : c;
            for (; r < i; ) e.insertBefore(s[r++], d);
          } else if (i === r) for (; a < n; ) (!f || !f.has(t[a])) && t[a].remove(), a++;
          else if (t[a] === s[i - 1] && s[r] === t[n - 1]) {
            const d = t[--n].nextSibling;
            e.insertBefore(s[r++], t[a++].nextSibling),
              e.insertBefore(s[--i], d),
              (t[n] = s[i]);
          } else {
            if (!f) {
              f = new Map();
              let l = r;
              for (; l < i; ) f.set(s[l], l++);
            }
            const d = f.get(t[a]);
            if (d != null)
              if (r < d && d < i) {
                let l = a,
                  k = 1,
                  u;
                for (; ++l < n && l < i && !((u = f.get(t[l])) == null || u !== d + k); )
                  k++;
                if (k > d - r) {
                  const p = t[a];
                  for (; r < d; ) e.insertBefore(s[r++], p);
                } else e.replaceChild(s[r++], t[a++]);
              } else a++;
            else t[a++].remove();
          }
        }
      }
      const Ne = '_$DX_DELEGATE';
      function bt(e, t, s, o = {}) {
        let n;
        return (
          we((i) => {
            (n = i), t === document ? e() : O(t, e(), t.firstChild ? null : void 0, s);
          }, o.owner),
          () => {
            n(), (t.textContent = '');
          }
        );
      }
      function se(e, t, s, o) {
        let n;
        const i = () => {
            const r = document.createElement('template');
            return (r.innerHTML = e), r.content.firstChild;
          },
          a = () => (n || (n = i())).cloneNode(!0);
        return (a.cloneNode = a), a;
      }
      function St(e, t = window.document) {
        const s = t[Ne] || (t[Ne] = new Set());
        for (let o = 0, n = e.length; o < n; o++) {
          const i = e[o];
          s.has(i) || (s.add(i), t.addEventListener(i, It));
        }
      }
      function vt(e, t) {
        t == null ? e.removeAttribute('class') : (e.className = t);
      }
      function O(e, t, s, o) {
        if ((s !== void 0 && !o && (o = []), typeof t != 'function'))
          return Se(e, t, o, s);
        q((n) => Se(e, t(), n, s), o);
      }
      function It(e) {
        let t = e.target;
        const s = `$$${e.type}`,
          o = e.target,
          n = e.currentTarget,
          i = (c) => Object.defineProperty(e, 'target', { configurable: !0, value: c }),
          a = () => {
            const c = t[s];
            if (c && !t.disabled) {
              const f = t[`${s}Data`];
              if ((f !== void 0 ? c.call(t, f, e) : c.call(t, e), e.cancelBubble)) return;
            }
            return (
              t.host &&
                typeof t.host != 'string' &&
                !t.host._$host &&
                t.contains(e.target) &&
                i(t.host),
              !0
            );
          },
          r = () => {
            for (; a() && (t = t._$host || t.parentNode || t.host); );
          };
        if (
          (Object.defineProperty(e, 'currentTarget', {
            configurable: !0,
            get() {
              return t || document;
            },
          }),
          e.composedPath)
        ) {
          const c = e.composedPath();
          i(c[0]);
          for (let f = 0; f < c.length - 2 && ((t = c[f]), !!a()); f++) {
            if (t._$host) {
              (t = t._$host), r();
              break;
            }
            if (t.parentNode === n) break;
          }
        } else r();
        i(o);
      }
      function Se(e, t, s, o, n) {
        for (; typeof s == 'function'; ) s = s();
        if (t === s) return s;
        const i = typeof t,
          a = o !== void 0;
        if (
          ((e = (a && s[0] && s[0].parentNode) || e), i === 'string' || i === 'number')
        ) {
          if (i === 'number' && ((t = t.toString()), t === s)) return s;
          if (a) {
            let r = s[0];
            r && r.nodeType === 3
              ? r.data !== t && (r.data = t)
              : (r = document.createTextNode(t)),
              (s = ee(e, s, o, r));
          } else
            s !== '' && typeof s == 'string'
              ? (s = e.firstChild.data = t)
              : (s = e.textContent = t);
        } else if (t == null || i === 'boolean') s = ee(e, s, o);
        else {
          if (i === 'function')
            return (
              q(() => {
                let r = t();
                for (; typeof r == 'function'; ) r = r();
                s = Se(e, r, s, o);
              }),
              () => s
            );
          if (Array.isArray(t)) {
            const r = [],
              c = s && Array.isArray(s);
            if (Ae(r, t, s, n)) return q(() => (s = Se(e, r, s, o, !0))), () => s;
            if (r.length === 0) {
              if (((s = ee(e, s, o)), a)) return s;
            } else
              c ? (s.length === 0 ? _e(e, r, o) : Pt(e, s, r)) : (s && ee(e), _e(e, r));
            s = r;
          } else if (t.nodeType) {
            if (Array.isArray(s)) {
              if (a) return (s = ee(e, s, o, t));
              ee(e, s, null, t);
            } else
              s == null || s === '' || !e.firstChild
                ? e.appendChild(t)
                : e.replaceChild(t, e.firstChild);
            s = t;
          }
        }
        return s;
      }
      function Ae(e, t, s, o) {
        let n = !1;
        for (let i = 0, a = t.length; i < a; i++) {
          let r = t[i],
            c = s && s[e.length],
            f;
          if (!(r == null || r === !0 || r === !1))
            if ((f = typeof r) == 'object' && r.nodeType) e.push(r);
            else if (Array.isArray(r)) n = Ae(e, r, c) || n;
            else if (f === 'function')
              if (o) {
                for (; typeof r == 'function'; ) r = r();
                n = Ae(e, Array.isArray(r) ? r : [r], Array.isArray(c) ? c : [c]) || n;
              } else e.push(r), (n = !0);
            else {
              const d = String(r);
              c && c.nodeType === 3 && c.data === d
                ? e.push(c)
                : e.push(document.createTextNode(d));
            }
        }
        return n;
      }
      function _e(e, t, s = null) {
        for (let o = 0, n = t.length; o < n; o++) e.insertBefore(t[o], s);
      }
      function ee(e, t, s, o) {
        if (s === void 0) return (e.textContent = '');
        const n = o || document.createTextNode('');
        if (t.length) {
          let i = !1;
          for (let a = t.length - 1; a >= 0; a--) {
            const r = t[a];
            if (n !== r) {
              const c = r.parentNode === e;
              !i && !a
                ? c
                  ? e.replaceChild(n, r)
                  : e.insertBefore(n, s)
                : c && r.remove();
            } else i = !0;
          }
        } else e.insertBefore(n, s);
        return [n];
      }
      const Tt = 'modulepreload',
        At = function (e, t) {
          return new URL(e, t).href;
        },
        Le = {},
        Oe = function (t, s, o) {
          let n = Promise.resolve();
          if (s && s.length > 0) {
            let a = function (d) {
              return Promise.all(
                d.map((l) =>
                  Promise.resolve(l).then(
                    (k) => ({ status: 'fulfilled', value: k }),
                    (k) => ({ status: 'rejected', reason: k }),
                  ),
                ),
              );
            };
            const r = document.getElementsByTagName('link'),
              c = document.querySelector('meta[property=csp-nonce]'),
              f =
                (c == null ? void 0 : c.nonce) ||
                (c == null ? void 0 : c.getAttribute('nonce'));
            n = a(
              s.map((d) => {
                if (((d = At(d, o)), d in Le)) return;
                Le[d] = !0;
                const l = d.endsWith('.css'),
                  k = l ? '[rel="stylesheet"]' : '';
                if (!!o)
                  for (let g = r.length - 1; g >= 0; g--) {
                    const m = r[g];
                    if (m.href === d && (!l || m.rel === 'stylesheet')) return;
                  }
                else if (document.querySelector(`link[href="${d}"]${k}`)) return;
                const p = document.createElement('link');
                if (
                  ((p.rel = l ? 'stylesheet' : Tt),
                  l || (p.as = 'script'),
                  (p.crossOrigin = ''),
                  (p.href = d),
                  f && p.setAttribute('nonce', f),
                  document.head.appendChild(p),
                  l)
                )
                  return new Promise((g, m) => {
                    p.addEventListener('load', g),
                      p.addEventListener('error', () =>
                        m(new Error(`Unable to preload CSS for ${d}`)),
                      );
                  });
              }),
            );
          }
          function i(a) {
            const r = new Event('vite:preloadError', { cancelable: !0 });
            if (((r.payload = a), window.dispatchEvent(r), !r.defaultPrevented)) throw a;
          }
          return n.then((a) => {
            for (const r of a || []) r.status === 'rejected' && i(r.reason);
            return t().catch(i);
          });
        },
        S = {
          getAllProjects: async () => {
            var e;
            return (e = window.PluginAPI) != null && e.getAllProjects
              ? window.PluginAPI.getAllProjects()
              : [];
          },
          getTasks: async () => {
            var e;
            return (e = window.PluginAPI) != null && e.getTasks
              ? window.PluginAPI.getTasks()
              : [];
          },
          addTask: async (e) => {
            var t;
            if ((t = window.PluginAPI) != null && t.addTask)
              return window.PluginAPI.addTask(e);
            throw new Error('PluginAPI.addTask not available');
          },
          updateTask: async (e, t) => {
            var s;
            if ((s = window.PluginAPI) != null && s.updateTask)
              return window.PluginAPI.updateTask(e, t);
            throw new Error('PluginAPI.updateTask not available');
          },
          deleteTask: async (e) => {
            var t;
            if ((t = window.PluginAPI) != null && t.deleteTask)
              return window.PluginAPI.deleteTask(e);
            throw new Error('PluginAPI.deleteTask not available');
          },
          persistDataSynced: async (e) => {
            var t;
            if ((t = window.PluginAPI) != null && t.persistDataSynced)
              return window.PluginAPI.persistDataSynced(e);
            throw new Error('PluginAPI.persistDataSynced not available');
          },
          loadSyncedData: async () => {
            var e;
            return (e = window.PluginAPI) != null && e.loadSyncedData
              ? window.PluginAPI.loadSyncedData()
              : null;
          },
          onMessage: (e) => {
            var t;
            (t = window.PluginAPI) != null &&
              t.onMessage &&
              window.PluginAPI.onMessage(e);
          },
          executeNodeScript: async (e) => {
            var t;
            if ((t = window.PluginAPI) != null && t.executeNodeScript)
              return window.PluginAPI.executeNodeScript(e);
            throw new Error('PluginAPI.executeNodeScript not available');
          },
          reorderTasks: async (e, t, s) => {
            var o;
            if ((o = window.PluginAPI) != null && o.reorderTasks)
              return window.PluginAPI.reorderTasks(e, t, s);
            throw new Error('PluginAPI.reorderTasks not available');
          },
        };
      var Et = se(
          '<div class="status error">This plugin requires the desktop version of Super Productivity to access local files. Please use the Electron app instead of the web version.',
        ),
        Dt = se('<div>'),
        $t = se(
          '<div class=sync-info><h3>Sync Status</h3><div class=sync-item><span class=sync-item-label>Status:</span><span class=sync-item-value></span></div><div class=sync-item><span class=sync-item-label>Last sync:</span><span class=sync-item-value></span></div><div class=sync-item><span class=sync-item-label>Tasks synced:</span><span class=sync-item-value></span></div><div class=button-group><button class=btn-secondary>Sync Now',
        ),
        xt = se('<div class=preview-container><h3>File Preview</h3><pre>'),
        Ct = se(
          '<div class=sync-md-app><h2>Sync.md Configuration</h2><div class=field-group><label for=filePath>Markdown File Path</label><input type=text id=filePath placeholder=/path/to/your/file.md><div class=help-text>Path to the markdown file to sync with</div></div><div class=field-group><label for=projectId>Project</label><select id=projectId><option value>Select a project...</option></select><div class=help-text>Tasks will be synced to this project</div></div><div class=field-group><label for=syncDirection>Sync Direction</label><select id=syncDirection><option value=bidirectional>Bidirectional (Two-way sync)</option><option value=fileToProject>File → Project only</option><option value=projectToFile>Project → File only</option></select><div class=help-text>Control how changes are synchronized</div></div><div class=button-group><button class=btn-primary>Save Configuration</button><button class=btn-secondary>Test Connection</button><button class=btn-secondary>Test Node Script',
        ),
        jt = se('<option>');
      const Ft = () => {
        console.log('Sync-MD Plugin: App component created');
        const [e, t] = L([]),
          [s, o] = L(null),
          [n, i] = L(''),
          [a, r] = L(''),
          [c, f] = L('bidirectional'),
          [d, l] = L(null),
          [k, u] = L(!1),
          [p, g] = L(null),
          [m, _] = L(0),
          [$, N] = L(null),
          [U, V] = L(!0);
        ct(async () => {
          console.log('Sync-MD Plugin: App mounted, initializing...'), await Ie();
        });
        const Ie = async () => {
            try {
              const h = await ne({ type: 'checkDesktopMode' });
              V((h == null ? void 0 : h.isDesktop) !== !1);
              const D = await S.getAllProjects();
              t(D);
              const x = await S.loadSyncedData();
              if (x) {
                const P = JSON.parse(x);
                o(P),
                  i(P.filePath || ''),
                  r(P.projectId || ''),
                  f(P.syncDirection || 'bidirectional'),
                  await ue();
              }
            } catch (h) {
              console.error('Failed to initialize:', h),
                v('Failed to initialize plugin', 'error');
            }
          },
          ue = async () => {
            try {
              const h = await ne({ type: 'getSyncInfo' });
              h &&
                (g(h.lastSyncTime ? new Date(h.lastSyncTime) : null),
                _(h.taskCount || 0));
            } catch (h) {
              console.error('Failed to get sync info:', h);
            }
          },
          Xe = async () => {
            if (!n() || !a()) {
              v('Please fill in all required fields', 'error');
              return;
            }
            const h = { filePath: n(), projectId: a(), syncDirection: c(), enabled: !0 };
            try {
              u(!0),
                await S.persistDataSynced(JSON.stringify(h)),
                o(h),
                await ne({ type: 'configUpdated', config: h }),
                v('Configuration saved successfully', 'success'),
                await ue();
            } catch (D) {
              console.error('Failed to save config:', D),
                v('Failed to save configuration', 'error');
            } finally {
              u(!1);
            }
          },
          Ze = async () => {
            var h, D, x;
            if (!n()) {
              v('Please enter a file path', 'error');
              return;
            }
            try {
              if (
                (u(!0),
                v('Testing file access...', 'info'),
                (h = window.PluginAPI) != null && h.executeNodeScript)
              )
                try {
                  const I = await window.PluginAPI.executeNodeScript({
                    script: `
              const fs = require('fs');
              const path = require('path');
              
              try {
                const absolutePath = path.resolve(args[0]);
                if (!fs.existsSync(absolutePath)) {
                  return { success: false, error: 'File not found' };
                }
                const content = fs.readFileSync(absolutePath, 'utf8');
                const lines = content.split('\\n').slice(0, 10);
                return { 
                  success: true, 
                  preview: lines.join('\\n') + (content.split('\\n').length > 10 ? '\\n...' : '')
                };
              } catch (error) {
                return { success: false, error: error.message };
              }
            `,
                    args: [n()],
                    timeout: 5e3,
                  });
                  I.success && (D = I.result) != null && D.success
                    ? (v('File is accessible and valid!', 'success'), N(I.result.preview))
                    : v(
                        ((x = I.result) == null ? void 0 : x.error) ||
                          'Failed to access file',
                        'error',
                      );
                  return;
                } catch {
                  console.log(
                    'Direct node script failed, falling back to message handler',
                  );
                }
              const P = await ne({ type: 'testFile', filePath: n() });
              P != null && P.success
                ? (v('File is accessible and valid!', 'success'),
                  P.preview && N(P.preview))
                : v((P == null ? void 0 : P.error) || 'Failed to access file', 'error');
            } catch (P) {
              console.error('Test failed:', P), v('Test failed: ' + P.message, 'error');
            } finally {
              u(!1);
            }
          },
          et = async () => {
            try {
              u(!0), v('Testing node script execution...', 'info');
              const h = await S.executeNodeScript({
                script: `
          const fs = require('fs');
          const path = require('path');
          
          // Test basic operations
          const testData = {
            message: 'Node script execution works!',
            timestamp: new Date().toISOString(),
            nodeVersion: process.version,
            platform: process.platform,
            canAccessFs: typeof fs.readFileSync === 'function',
            canAccessPath: typeof path.join === 'function'
          };
          
          return testData;
        `,
                timeout: 5e3,
              });
              h.success
                ? (console.log('Node script test result:', h.result),
                  v(
                    `Success! Node ${h.result.nodeVersion} on ${h.result.platform}`,
                    'success',
                  ))
                : v(`Node script test failed: ${h.error}`, 'error');
            } catch (h) {
              console.error('Node script test failed:', h),
                v('Node script test failed: ' + h.message, 'error');
            } finally {
              u(!1);
            }
          },
          tt = async () => {
            var h, D, x, P, I, H;
            if (!s() || !s().enabled) {
              v('Please save configuration first', 'error');
              return;
            }
            try {
              if (
                (u(!0),
                v('Syncing...', 'info'),
                (h = window.PluginAPI) != null && h.executeNodeScript)
              )
                try {
                  const F = await window.PluginAPI.executeNodeScript({
                    script: `
              const fs = require('fs');
              const path = require('path');
              
              try {
                const absolutePath = path.resolve(args[0]);
                const content = fs.readFileSync(absolutePath, 'utf8');
                return { success: true, content };
              } catch (error) {
                return { success: false, error: error.message };
              }
            `,
                    args: [s().filePath],
                    timeout: 5e3,
                  });
                  if (!F.success || !((D = F.result) != null && D.success))
                    throw new Error(
                      ((x = F.result) == null ? void 0 : x.error) ||
                        'Failed to read file',
                    );
                  const Y = F.result.content,
                    Q = (await S.getTasks()).filter((b) => b.projectId === s().projectId),
                    G = (await S.getAllProjects()).find((b) => b.id === s().projectId);
                  let X = Q;
                  if (G != null && G.taskIds) {
                    const b = new Map(Q.map((C) => [C.id, C]));
                    X = G.taskIds.map((C) => b.get(C)).filter((C) => C !== void 0);
                  }
                  const { replicateMD: fe } = await Oe(
                      async () => {
                        const { replicateMD: b } = await Promise.resolve().then(() => Ue);
                        return { replicateMD: b };
                      },
                      void 0,
                      import.meta.url,
                    ),
                    w = fe(Y, X, s().syncDirection);
                  if (!w.success) throw new Error(w.error || 'Sync failed');
                  if (
                    s().syncDirection === 'fileToProject' ||
                    s().syncDirection === 'bidirectional'
                  ) {
                    const b = new Map();
                    for (const y of w.operations)
                      if (y.target === 'task')
                        try {
                          switch (y.type) {
                            case 'add':
                              if (y.data) {
                                const B = await S.addTask({
                                  title: y.data.title || '',
                                  isDone: y.data.isDone || !1,
                                  projectId: s().projectId,
                                  parentId: y.parentId || void 0,
                                  notes: y.data.notes || void 0,
                                });
                                y.tempId && b.set(y.tempId, B);
                              }
                              break;
                            case 'update':
                              y.taskId &&
                                y.data &&
                                (await S.updateTask(y.taskId, {
                                  title: y.data.title,
                                  isDone: y.data.isDone,
                                }));
                              break;
                            case 'delete':
                              y.taskId &&
                                (await S.updateTask(y.taskId, {
                                  isDone: !0,
                                  title: `[DELETED] ${((P = y.data) == null ? void 0 : P.title) || 'Task'}`,
                                }));
                              break;
                          }
                        } catch (B) {
                          console.error(`Failed to ${y.type} task:`, B);
                        }
                    const { parseMarkdownToTree: C } = await Oe(
                        async () => {
                          const { parseMarkdownToTree: y } = await Promise.resolve().then(
                            () => Ue,
                          );
                          return { parseMarkdownToTree: y };
                        },
                        void 0,
                        import.meta.url,
                      ),
                      Z = C(Y),
                      J = (await S.getTasks()).filter(
                        (y) => y.projectId === s().projectId,
                      ),
                      R = [];
                    if (
                      (((y) => {
                        y.forEach((B) => {
                          const ie = J.find(
                            (pe) => (B.id && pe.id === B.id) || pe.title === B.title,
                          );
                          ie && !ie.parentId && R.push(ie.id);
                        });
                      })(Z),
                      J.forEach((y) => {
                        !y.parentId && !R.includes(y.id) && R.push(y.id);
                      }),
                      R.length > 0)
                    )
                      try {
                        await S.reorderTasks(R, s().projectId, 'project'),
                          console.log('Reordered tasks to match markdown order:', R);
                      } catch (y) {
                        console.error('Failed to reorder tasks:', y);
                      }
                  }
                  if (
                    (s().syncDirection === 'projectToFile' ||
                      s().syncDirection === 'bidirectional') &&
                    w.updatedMarkdown !== Y
                  ) {
                    const b = await window.PluginAPI.executeNodeScript({
                      script: `
                  const fs = require('fs');
                  const path = require('path');
                  
                  try {
                    const absolutePath = path.resolve(args[0]);
                    const content = args[1];
                    
                    // Create backup
                    if (fs.existsSync(absolutePath)) {
                      const backupPath = absolutePath + '.backup';
                      fs.copyFileSync(absolutePath, backupPath);
                    }
                    
                    // Write new content
                    fs.writeFileSync(absolutePath, content, 'utf8');
                    return { success: true };
                  } catch (error) {
                    return { success: false, error: error.message };
                  }
                `,
                      args: [s().filePath, w.updatedMarkdown],
                      timeout: 5e3,
                    });
                    if (!b.success || !((I = b.result) != null && I.success))
                      throw new Error(
                        ((H = b.result) == null ? void 0 : H.error) ||
                          'Failed to write file',
                      );
                  }
                  v(
                    `Sync completed! Added: ${w.tasksAdded}, Updated: ${w.tasksUpdated}`,
                    'success',
                  ),
                    await ue();
                  return;
                } catch (F) {
                  console.log('Direct sync failed, falling back to message handler:', F);
                }
              const M = await ne({ type: 'syncNow' });
              M != null && M.success
                ? (v('Sync completed successfully', 'success'), await ue())
                : v((M == null ? void 0 : M.error) || 'Sync failed', 'error');
            } catch (M) {
              console.error('Sync failed:', M), v('Sync failed: ' + M.message, 'error');
            } finally {
              u(!1);
            }
          },
          ne = async (h) => (
            console.log('Sending message to plugin:', h),
            new Promise((D) => {
              const x = Date.now().toString(),
                P = (I) => {
                  var H, M, F;
                  console.log('Received message event:', I.data),
                    ((H = I.data) == null ? void 0 : H.messageId) === x
                      ? (window.removeEventListener('message', P),
                        D(I.data.response || I.data))
                      : ((M = I.data) == null ? void 0 : M.type) ===
                          'PLUGIN_MESSAGE_RESPONSE' &&
                        ((F = I.data) == null ? void 0 : F.messageId) === x &&
                        (window.removeEventListener('message', P),
                        D(I.data.response || I.data.result));
                };
              window.addEventListener('message', P),
                window.parent.postMessage(
                  { type: 'PLUGIN_MESSAGE', message: h, messageId: x },
                  '*',
                ),
                setTimeout(() => {
                  window.removeEventListener('message', P),
                    D({ success: !1, error: 'Request timeout' });
                }, 1e4);
            })
          ),
          v = (h, D) => {
            l({ message: h, type: D }), setTimeout(() => l(null), 5e3);
          };
        return (() => {
          var h = Ct(),
            D = h.firstChild,
            x = D.nextSibling,
            P = x.firstChild,
            I = P.nextSibling,
            H = x.nextSibling,
            M = H.firstChild,
            F = M.nextSibling;
          F.firstChild;
          var Y = H.nextSibling,
            xe = Y.firstChild,
            Q = xe.nextSibling,
            Ce = Y.nextSibling,
            G = Ce.firstChild,
            X = G.nextSibling,
            fe = X.nextSibling;
          return (
            O(
              h,
              te(ge, {
                get when() {
                  return !U();
                },
                get children() {
                  return Et();
                },
              }),
              x,
            ),
            (I.$$input = (w) => i(w.currentTarget.value)),
            F.addEventListener('change', (w) => r(w.currentTarget.value)),
            O(
              F,
              te(kt, {
                get each() {
                  return e();
                },
                children: (w) =>
                  (() => {
                    var b = jt();
                    return O(b, () => w.title), q(() => (b.value = w.id)), b;
                  })(),
              }),
              null,
            ),
            Q.addEventListener('change', (w) => f(w.currentTarget.value)),
            (G.$$click = Xe),
            (X.$$click = Ze),
            (fe.$$click = et),
            O(
              h,
              te(ge, {
                get when() {
                  return d();
                },
                get children() {
                  var w = Dt();
                  return O(w, () => d().message), q(() => vt(w, `status ${d().type}`)), w;
                },
              }),
              null,
            ),
            O(
              h,
              te(ge, {
                get when() {
                  return s();
                },
                get children() {
                  var w = $t(),
                    b = w.firstChild,
                    C = b.nextSibling,
                    Z = C.firstChild,
                    re = Z.nextSibling,
                    J = C.nextSibling,
                    R = J.firstChild,
                    je = R.nextSibling,
                    y = J.nextSibling,
                    B = y.firstChild,
                    ie = B.nextSibling,
                    pe = y.nextSibling,
                    Fe = pe.firstChild;
                  return (
                    O(re, () => {
                      var he;
                      return (he = s()) != null && he.enabled
                        ? 'Active'
                        : 'Not configured';
                    }),
                    O(
                      je,
                      (() => {
                        var he = mt(() => !!p());
                        return () => (he() ? p().toLocaleString() : 'Never');
                      })(),
                    ),
                    O(ie, m),
                    (Fe.$$click = tt),
                    q(() => (Fe.disabled = k())),
                    w
                  );
                },
              }),
              null,
            ),
            O(
              h,
              te(ge, {
                get when() {
                  return $();
                },
                get children() {
                  var w = xt(),
                    b = w.firstChild,
                    C = b.nextSibling;
                  return O(C, $), w;
                },
              }),
              null,
            ),
            q(
              (w) => {
                var b = k(),
                  C = k(),
                  Z = k(),
                  re = k(),
                  J = k(),
                  R = k();
                return (
                  b !== w.e && (I.disabled = w.e = b),
                  C !== w.t && (F.disabled = w.t = C),
                  Z !== w.a && (Q.disabled = w.a = Z),
                  re !== w.o && (G.disabled = w.o = re),
                  J !== w.i && (X.disabled = w.i = J),
                  R !== w.n && (fe.disabled = w.n = R),
                  w
                );
              },
              { e: void 0, t: void 0, a: void 0, o: void 0, i: void 0, n: void 0 },
            ),
            q(() => (I.value = n())),
            q(() => (F.value = a())),
            q(() => (Q.value = c())),
            h
          );
        })();
      };
      St(['input', 'click']);
      function De(e) {
        const t = e.split(`
`),
          s = [],
          o = [];
        t.forEach((i, a) => {
          const r = i.match(/^(\s*)([-*])\s*\[([ x])\]\s*(.*)$/);
          if (!r) return;
          const [, c, f, d, l] = r,
            k = c.length,
            u = d.toLowerCase() === 'x',
            p = l.match(/^\(([^)]+)\)\s*(.+)$/),
            g = p ? p[1] : void 0,
            m = p ? p[2] : l,
            _ = {
              id: g,
              title: m.trim(),
              isDone: u,
              children: [],
              level: Math.floor(k / 2),
            };
          for (; o.length > 0 && o[o.length - 1].indent >= k; ) o.pop();
          if (o.length === 0) s.push(_);
          else {
            const $ = o[o.length - 1].node;
            $.children.push(_), (_.parentId = $.id || null);
          }
          o.push({ node: _, indent: k });
        });
        const n = (i, a = []) => {
          i.forEach((r) => {
            const c = [];
            r.children.forEach((f) => {
              c.push(f);
            }),
              (r.children = c),
              n(r.children, [...a, r]);
          });
        };
        return n(s), s;
      }
      function Je(e) {
        const t = new Map(),
          s = [],
          o = new Set();
        return (
          e.forEach((n) => {
            const i = {
              id: n.id,
              title: n.title,
              isDone: n.isDone || !1,
              children: [],
              notes: n.notes,
              parentId: n.parentId || null,
              level: 0,
            };
            t.set(n.id, i);
          }),
          e.forEach((n) => {
            const i = t.get(n.id);
            if (n.parentId && t.has(n.parentId)) {
              const a = t.get(n.parentId);
              o.has(n.id) || (a.children.push(i), o.add(n.id), (i.level = a.level + 1));
            }
            n.subTaskIds &&
              n.subTaskIds.length > 0 &&
              ((i.children = []),
              n.subTaskIds.forEach((a) => {
                const r = t.get(a);
                r &&
                  !o.has(a) &&
                  (i.children.push(r),
                  (r.parentId = n.id),
                  (r.level = i.level + 1),
                  o.add(a));
              })),
              !n.parentId && !o.has(n.id) && s.push(i);
          }),
          s
        );
      }
      function $e(e, t = 0, s = !1) {
        const o = [];
        return (
          e.forEach((n) => {
            const i = '  '.repeat(t),
              a = n.isDone ? '[x]' : '[ ]',
              r = s && n.id ? `(${n.id}) ` : '',
              c = `${i}- ${a} ${r}${n.title}`;
            o.push(c),
              n.notes &&
                n.notes
                  .split(
                    `
`,
                  )
                  .filter((d) => d.trim())
                  .forEach((d) => {
                    o.push(`${i}  - ${d.trim()}`);
                  }),
              n.children.length > 0 && o.push($e(n.children, t + 1, s));
          }),
          o.join(`
`)
        );
      }
      const ye = (e, t) => {
        for (const s of t) {
          if ((e.id && s.id && e.id === s.id) || e.title === s.title) return s;
          const o = ye(e, s.children);
          if (o) return o;
        }
        return null;
      };
      function Ke(e, t, s) {
        const o = [];
        if (s === 'fileToProject' || s === 'bidirectional') {
          const n = (i, a = null) => {
            const r = ye(i, t);
            r
              ? (r.isDone !== i.isDone || r.title !== i.title) &&
                o.push({
                  type: 'update',
                  target: 'task',
                  taskId: r.id,
                  data: { title: i.title, isDone: i.isDone },
                })
              : o.push({
                  type: 'add',
                  target: 'task',
                  parentId: a,
                  data: { title: i.title, isDone: i.isDone, notes: i.notes },
                }),
              i.children.forEach((c) => {
                n(c, i.id || (r == null ? void 0 : r.id) || null);
              });
          };
          e.forEach((i) => n(i));
        }
        if (s === 'projectToFile' || s === 'bidirectional') {
          const n = (a) => {
            const r = ye(a, e);
            r
              ? (r.isDone !== a.isDone || r.title !== a.title) &&
                o.push({
                  type: 'update',
                  target: 'markdown',
                  taskId: a.id,
                  data: { title: a.title, isDone: a.isDone, notes: a.notes },
                })
              : s === 'projectToFile'
                ? o.push({
                    type: 'add',
                    target: 'markdown',
                    taskId: a.id,
                    data: { title: a.title, isDone: a.isDone, notes: a.notes },
                  })
                : s === 'bidirectional' &&
                  o.push({ type: 'delete', target: 'task', taskId: a.id }),
              a.children.forEach(n);
          };
          t.forEach(n);
          const i = (a) => {
            ye(a, t) ||
              o.push({
                type: 'delete',
                target: 'markdown',
                taskId: a.id,
                data: { title: a.title },
              }),
              a.children.forEach(i);
          };
          e.forEach(i);
        }
        return o;
      }
      function ze(e, t, s) {
        try {
          const o = De(e),
            n = Je(t),
            i = Ke(o, n, s);
          let a = JSON.parse(JSON.stringify(o));
          if (s === 'projectToFile' || s === 'bidirectional') {
            const l = (u, p) => {
                if (!u) return null;
                for (const g of p) {
                  if (g.id === u) return g;
                  const m = l(u, g.children);
                  if (m) return m;
                }
                return null;
              },
              k = (u, p, g) => {
                if (!u && !p) return !1;
                for (let m = 0; m < g.length; m++) {
                  if ((u && g[m].id === u) || (p && g[m].title === p))
                    return g.splice(m, 1), !0;
                  if (k(u, p, g[m].children)) return !0;
                }
                return !1;
              };
            if (s === 'projectToFile') {
              const u = (p, g = 1) =>
                p.map((m) => ({
                  id: m.id,
                  title: m.title,
                  isDone: m.isDone,
                  notes: m.notes,
                  level: g,
                  children: u(m.children, g + 1),
                }));
              a = n.map((p) => ({
                id: p.id,
                title: p.title,
                isDone: p.isDone,
                notes: p.notes,
                level: 0,
                children: u(p.children),
              }));
            } else
              i.filter((u) => u.target === 'markdown').forEach((u) => {
                var p;
                if (u.type === 'add' && u.data) {
                  const g = {
                    id: u.taskId,
                    title: u.data.title || '',
                    isDone: u.data.isDone || !1,
                    children: [],
                    notes: u.data.notes,
                    level: 0,
                  };
                  a.push(g);
                } else if (u.type === 'update' && u.data) {
                  const g = l(u.taskId, a);
                  g &&
                    ((g.title = u.data.title || g.title),
                    (g.isDone = u.data.isDone !== void 0 ? u.data.isDone : g.isDone),
                    u.data.notes !== void 0 && (g.notes = u.data.notes));
                } else
                  u.type === 'delete' &&
                    k(u.taskId, (p = u.data) == null ? void 0 : p.title, a);
              });
          }
          const r = $e(a, 0, !1),
            c = i.filter((l) => l.type === 'add' && l.target === 'task').length,
            f = i.filter((l) => l.type === 'update' && l.target === 'task').length,
            d = i.filter((l) => l.type === 'delete' && l.target === 'task').length;
          return {
            success: !0,
            operations: i,
            updatedMarkdown: r,
            conflicts: [],
            tasksAdded: c,
            tasksUpdated: f,
            tasksDeleted: d,
          };
        } catch (o) {
          return {
            success: !1,
            operations: [],
            updatedMarkdown: e,
            conflicts: [],
            error: o.message,
            tasksAdded: 0,
            tasksUpdated: 0,
            tasksDeleted: 0,
          };
        }
      }
      const Ue = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            compareTrees: Ke,
            parseMarkdownToTree: De,
            replicateMD: ze,
            tasksToTree: Je,
            treeToMarkdown: $e,
          },
          Symbol.toStringTag,
          { value: 'Module' },
        ),
      );
      class Ye {
        constructor(t) {
          oe(this, 'watchInterval', null);
          oe(this, 'lastFileContent', null);
          oe(this, 'lastSyncTime', 0);
          oe(this, 'isWatching', !1);
          this.options = t;
        }
        async start() {
          if (this.isWatching) {
            console.log('File watcher already running');
            return;
          }
          (this.isWatching = !0),
            console.log('Starting file watcher for:', this.options.config.filePath),
            await this.performSync(),
            (this.watchInterval = window.setInterval(async () => {
              try {
                await this.checkAndSync();
              } catch (t) {
                console.error('Error in file watcher:', t),
                  this.options.onError && this.options.onError(t);
              }
            }, 3e4));
        }
        stop() {
          this.watchInterval &&
            (clearInterval(this.watchInterval), (this.watchInterval = null)),
            (this.isWatching = !1),
            console.log('File watcher stopped');
        }
        async checkAndSync() {
          if (this.options.config.enabled)
            try {
              const t = await this.readFile(this.options.config.filePath);
              t !== this.lastFileContent &&
                (console.log('File changed, syncing...'),
                (this.lastFileContent = t),
                await this.performSync());
            } catch (t) {
              throw (console.error('Error checking file:', t), t);
            }
        }
        async performSync() {
          try {
            const { config: t } = this.options,
              s = await this.readFile(t.filePath);
            this.lastFileContent = s;
            const n = (await S.getTasks()).filter((f) => f.projectId === t.projectId),
              a = (await S.getAllProjects()).find((f) => f.id === t.projectId);
            let r = n;
            if (a != null && a.taskIds) {
              const f = new Map(n.map((d) => [d.id, d]));
              r = a.taskIds.map((d) => f.get(d)).filter((d) => d !== void 0);
            }
            const c = ze(s, r, t.syncDirection);
            if (!c.success) throw new Error(c.error || 'Sync failed');
            (t.syncDirection === 'fileToProject' ||
              t.syncDirection === 'bidirectional') &&
              (await this.applyTaskOperations(c, t.projectId)),
              (t.syncDirection === 'projectToFile' ||
                t.syncDirection === 'bidirectional') &&
                c.updatedMarkdown !== s &&
                (await this.writeFile(t.filePath, c.updatedMarkdown),
                (this.lastFileContent = c.updatedMarkdown)),
              (this.lastSyncTime = Date.now()),
              this.options.onSync && this.options.onSync(c);
          } catch (t) {
            throw (console.error('Sync error:', t), t);
          }
        }
        async applyTaskOperations(t, s) {
          var n;
          const o = new Map();
          for (const i of t.operations)
            if (i.target === 'task')
              try {
                switch (i.type) {
                  case 'add':
                    if (i.data) {
                      const a = {
                          title: i.data.title || '',
                          isDone: i.data.isDone || !1,
                          projectId: s,
                          parentId: i.parentId || void 0,
                          notes: i.data.notes || void 0,
                        },
                        r = await S.addTask(a);
                      console.log('Created task:', r), i.tempId && o.set(i.tempId, r);
                    }
                    break;
                  case 'update':
                    i.taskId &&
                      i.data &&
                      (await S.updateTask(i.taskId, {
                        title: i.data.title,
                        isDone: i.data.isDone,
                      }),
                      console.log('Updated task:', i.taskId));
                    break;
                  case 'delete':
                    i.taskId &&
                      (await S.updateTask(i.taskId, {
                        isDone: !0,
                        title: `[DELETED] ${((n = i.data) == null ? void 0 : n.title) || 'Task'}`,
                      }),
                      console.log(
                        'Marked task as deleted (deleteTask not available):',
                        i.taskId,
                      ));
                    break;
                }
              } catch (a) {
                console.error(`Failed to ${i.type} task:`, a);
              }
          await this.updateTaskOrder(s);
        }
        async updateTaskOrder(t) {
          try {
            const s = await this.readFile(this.options.config.filePath),
              o = De(s),
              i = (await S.getTasks()).filter((r) => r.projectId === t),
              a = [];
            o.forEach((r) => {
              const c = i.find((f) => (r.id && f.id === r.id) || f.title === r.title);
              c && !c.parentId && a.push(c.id);
            }),
              i.forEach((r) => {
                !r.parentId && !a.includes(r.id) && a.push(r.id);
              }),
              a.length > 0 &&
                (await S.reorderTasks(a, t, 'project'),
                console.log('Reordered tasks to match markdown order:', a));
          } catch (s) {
            console.error('Failed to update task order:', s);
          }
        }
        async readFile(t) {
          var o, n;
          if (!S.executeNodeScript)
            throw new Error('Node script execution not available');
          const s = await S.executeNodeScript({
            script: `
        const fs = require('fs');
        const path = require('path');
        
        try {
          const absolutePath = path.resolve(args[0]);
          const content = fs.readFileSync(absolutePath, 'utf8');
          return { success: true, content };
        } catch (error) {
          return { success: false, error: error.message };
        }
      `,
            args: [t],
            timeout: 5e3,
          });
          if (!s.success) throw new Error(`Failed to read file: ${s.error}`);
          if (!((o = s.result) != null && o.success))
            throw new Error(
              `Cannot read file: ${((n = s.result) == null ? void 0 : n.error) || 'Unknown error'}`,
            );
          return s.result.content;
        }
        async writeFile(t, s) {
          var n, i;
          if (!S.executeNodeScript)
            throw new Error('Node script execution not available');
          const o = await S.executeNodeScript({
            script: `
        const fs = require('fs');
        const path = require('path');
        
        try {
          const absolutePath = path.resolve(args[0]);
          const content = args[1];
          
          // Create backup
          if (fs.existsSync(absolutePath)) {
            const backupPath = absolutePath + '.backup';
            fs.copyFileSync(absolutePath, backupPath);
          }
          
          // Write new content
          fs.writeFileSync(absolutePath, content, 'utf8');
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      `,
            args: [t, s],
            timeout: 5e3,
          });
          if (!o.success) throw new Error(`Failed to write file: ${o.error}`);
          if (!((n = o.result) != null && n.success))
            throw new Error(
              `Cannot write file: ${((i = o.result) == null ? void 0 : i.error) || 'Unknown error'}`,
            );
        }
        async getSyncInfo() {
          const s = (await S.getTasks()).filter(
            (o) => o.projectId === this.options.config.projectId,
          );
          return {
            lastSyncTime: this.lastSyncTime,
            taskCount: s.length,
            isWatching: this.isWatching,
          };
        }
      }
      let T = null;
      function Mt() {
        var e;
        return (e = window.PluginAPI) != null && e.onMessage
          ? (console.log('Registering message handler'),
            window.PluginAPI.onMessage(async (t) => {
              var s, o;
              console.log('Background received message:', t);
              try {
                let n = { success: !0 };
                switch (t.type) {
                  case 'configUpdated':
                    T && (T.stop(), (T = null)),
                      (s = t.config) != null &&
                        s.enabled &&
                        ((T = new Ye({
                          config: t.config,
                          onSync: (a) => {
                            console.log('Sync completed:', a),
                              window.parent.postMessage(
                                { type: 'SYNC_COMPLETED', result: a },
                                '*',
                              );
                          },
                          onError: (a) => {
                            console.error('Sync error:', a),
                              window.parent.postMessage(
                                { type: 'SYNC_ERROR', error: a.message },
                                '*',
                              );
                          },
                        })),
                        await T.start());
                    break;
                  case 'testFile':
                    const { filePath: i } = t;
                    if (!i) n = { success: !1, error: 'No file path provided' };
                    else
                      try {
                        const a = await Nt(i);
                        n = {
                          success: !0,
                          preview:
                            a
                              .split(
                                `
`,
                              )
                              .slice(0, 10).join(`
`) +
                            (a.split(`
`).length > 10
                              ? `
...`
                              : ''),
                        };
                      } catch (a) {
                        n = { success: !1, error: a.message };
                      }
                    break;
                  case 'syncNow':
                    T
                      ? (await T.performSync(), (n = { success: !0 }))
                      : (n = { success: !1, error: 'File watcher not initialized' });
                    break;
                  case 'getSyncInfo':
                    T
                      ? (n = { ...(await T.getSyncInfo()), success: !0 })
                      : (n = {
                          success: !0,
                          lastSyncTime: 0,
                          taskCount: 0,
                          isWatching: !1,
                        });
                    break;
                  case 'checkDesktopMode':
                    n = {
                      success: !0,
                      isDesktop:
                        typeof window < 'u' &&
                        ((o = window.PluginAPI) == null
                          ? void 0
                          : o.executeNodeScript) !== void 0,
                    };
                    break;
                  default:
                    n = { success: !1, error: `Unknown message type: ${t.type}` };
                }
                return n;
              } catch (n) {
                return (
                  console.error('Error handling message:', n),
                  { success: !1, error: n.message }
                );
              }
            }),
            !0)
          : !1;
      }
      async function Nt(e) {
        var s, o, n;
        if (!((s = window.PluginAPI) != null && s.executeNodeScript))
          throw new Error('Node script execution not available');
        const t = await window.PluginAPI.executeNodeScript({
          script: `
      const fs = require('fs');
      const path = require('path');
      
      try {
        const absolutePath = path.resolve(args[0]);
        if (!fs.existsSync(absolutePath)) {
          return { success: false, error: 'File not found' };
        }
        const content = fs.readFileSync(absolutePath, 'utf8');
        return { success: true, content };
      } catch (error) {
        return { success: false, error: error.message };
      }
    `,
          args: [e],
          timeout: 5e3,
        });
        if (!t.success) throw new Error(t.error || 'Failed to execute node script');
        if (!((o = t.result) != null && o.success))
          throw new Error(
            ((n = t.result) == null ? void 0 : n.error) || 'Failed to read file',
          );
        return t.result.content;
      }
      window.addEventListener('load', async () => {
        var n, i, a;
        console.log('Sync-MD background script loaded');
        let e = !1,
          t = 0;
        const s = 10;
        for (; !e && t < s; )
          (e = Mt()),
            e ||
              (console.log(`Waiting for PluginAPI... attempt ${t + 1}/${s}`),
              await new Promise((r) => setTimeout(r, 100))),
            t++;
        e || console.error('Failed to register message handler after', s, 'attempts'),
          (n = window.PluginAPI) != null &&
            n.registerHook &&
            (console.log('Registering task update hooks for immediate sync'),
            window.PluginAPI.registerHook('taskUpdate', async () => {
              T &&
                (console.log('Task updated - triggering immediate sync'),
                await T.performSync());
            }),
            window.PluginAPI.registerHook('taskComplete', async () => {
              T &&
                (console.log('Task completed - triggering immediate sync'),
                await T.performSync());
            }),
            window.PluginAPI.registerHook('taskDelete', async () => {
              T &&
                (console.log('Task deleted - triggering immediate sync'),
                await T.performSync());
            }),
            window.PluginAPI.registerHook('action', async (r) => {
              var c, f, d, l, k, u, p, g;
              T &&
                ((r == null ? void 0 : r.type) === '[Project] Update Project' ||
                (r == null ? void 0 : r.type) === 'UpdateProject'
                  ? (((f =
                      (c = r == null ? void 0 : r.payload) == null
                        ? void 0
                        : c.changes) != null &&
                      f.taskIds) ||
                      ((k =
                        (l =
                          (d = r == null ? void 0 : r.payload) == null
                            ? void 0
                            : d.project) == null
                          ? void 0
                          : l.changes) != null &&
                        k.taskIds)) &&
                    (await T.performSync())
                  : (r == null ? void 0 : r.type) === '[Task] Update Task'
                    ? (g =
                        (p =
                          (u = r == null ? void 0 : r.payload) == null
                            ? void 0
                            : u.task) == null
                          ? void 0
                          : p.changes) != null &&
                      g.subTaskIds &&
                      (await T.performSync())
                    : r != null &&
                      r.type &&
                      (r.type.includes('Move Task') ||
                        r.type.includes('move Task') ||
                        r.type.includes('Move task') ||
                        r.type === '[WorkContext] Move Task In Today List' ||
                        r.type.includes('Reorder') ||
                        r.type.includes('reorder')) &&
                      (await T.performSync()));
            }));
        const o = await ((a =
          (i = window.PluginAPI) == null ? void 0 : i.loadSyncedData) == null
          ? void 0
          : a.call(i));
        if (o)
          try {
            const r = JSON.parse(o);
            r.enabled &&
              ((T = new Ye({
                config: r,
                onSync: (c) => {
                  console.log('Auto-sync completed:', c);
                },
                onError: (c) => {
                  console.error('Auto-sync error:', c);
                },
              })),
              await T.start());
          } catch (r) {
            console.error('Failed to load saved config:', r);
          }
      });
      console.log('Sync-MD Plugin: index.tsx loaded');
      console.log(
        'Sync-MD Plugin: window.PluginAPI available?',
        typeof window.PluginAPI < 'u',
      );
      function Qe() {
        const e = document.getElementById('root');
        console.log('Sync-MD Plugin: root element:', e),
          typeof window.PluginAPI < 'u' && e
            ? (console.log('Sync-MD Plugin: PluginAPI is available, rendering app...'),
              bt(() => te(Ft, {}), e),
              console.log('Sync-MD Plugin: App rendered'))
            : (console.log('Sync-MD Plugin: Waiting for PluginAPI...'),
              setTimeout(Qe, 100));
      }
      Qe();
    </script>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 16px;
        font-family:
          -apple-system,
          BlinkMacSystemFont,
          Segoe UI,
          Roboto,
          Oxygen,
          Ubuntu,
          Cantarell,
          sans-serif;
        font-size: 14px;
        color: var(--text-color, #333);
        background-color: transparent;
      }
      .sync-md-app {
        max-width: 600px;
        margin: 0 auto;
      }
      h2 {
        margin-top: 0;
        margin-bottom: 16px;
        font-size: 18px;
        font-weight: 500;
      }
      h3 {
        font-size: 16px;
        margin-bottom: 12px;
      }
      .field-group {
        margin-bottom: 16px;
      }
      label {
        display: block;
        margin-bottom: 4px;
        font-weight: 500;
        font-size: 13px;
        color: var(--text-secondary, #666);
      }
      input,
      select,
      textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border-color, #ccc);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--input-bg, #fff);
        color: var(--text-color, #333);
      }
      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary-color, #2196f3);
        box-shadow: 0 0 0 2px #2196f333;
      }
      input:disabled,
      select:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .btn-primary {
        background-color: var(--primary-color, #2196f3);
        color: #fff;
      }
      .btn-primary:hover:not(:disabled) {
        background-color: var(--primary-dark, #1976d2);
      }
      .btn-secondary {
        background-color: transparent;
        color: var(--primary-color, #2196f3);
        border: 1px solid var(--primary-color, #2196f3);
      }
      .btn-secondary:hover:not(:disabled) {
        background-color: #2196f314;
      }
      .button-group {
        display: flex;
        gap: 8px;
        margin-top: 16px;
      }
      .status {
        padding: 8px;
        border-radius: 4px;
        margin-top: 16px;
        font-size: 13px;
      }
      .status.success {
        background-color: #4caf501a;
        color: #4caf50;
        border: 1px solid #4caf50;
      }
      .status.error {
        background-color: #f443361a;
        color: #f44336;
        border: 1px solid #f44336;
      }
      .status.info {
        background-color: #2196f31a;
        color: #2196f3;
        border: 1px solid #2196f3;
      }
      .sync-info {
        margin-top: 24px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color, #ccc);
      }
      .sync-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        font-size: 13px;
      }
      .sync-item-label {
        color: var(--text-secondary, #666);
      }
      .sync-item-value {
        font-weight: 500;
      }
      .preview-container {
        margin-top: 16px;
        padding: 12px;
        background-color: var(--bg-secondary, #f5f5f5);
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
      }
      .preview-container pre {
        margin: 0;
        font-family:
          Consolas,
          Monaco,
          Courier New,
          monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .help-text {
        font-size: 12px;
        color: var(--text-secondary, #666);
        margin-top: 4px;
      }
      @media (prefers-color-scheme: dark) {
        body {
          --text-color: #e0e0e0;
          --text-secondary: #999;
          --background-color: #1e1e1e;
          --border-color: #444;
          --input-bg: #2a2a2a;
          --bg-secondary: #2a2a2a;
          --primary-color: #42a5f5;
          --primary-dark: #1e88e5;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
